## 一、全局锁

### 1. 语法

- 加锁
```sql
flush tables with read lock;
```

- 备份
```bash
mysqldump -uroot -p123456 itcast>itcast.sql
```

- 释放锁
```sql
unlock tables;
```

### 2. 特点

```text
如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆
```

```text
如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟
```

### 3. 一致性备份（InnoDB）

```text
在InnoDB引擎中，可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份
```

```bash
mysqldump --single-transaction -uroot -p123456 itcast>itcast.sql
```

## 二、表级锁

### 1. 表锁

- 加锁
```sql
lock tables 表名... read;
lock tables 表名... write;
```

- 语义
```text
read：本客户端可读不可写，其他客户端可读写阻塞
write：本客户端可读可写，其他客户端读阻塞写阻塞
```

- 释放锁
```sql
unlock tables;
```

```text
unlock tables / 客户端断开连接
```

### 2. 元数据锁（meta data lock，MDL）

- 查看元数据锁
```sql
SELECT object_type, object_schema, object_name, lock_type, lock_duration
FROM performance_schema.metadata_locks;
```

- SQL－锁类型－说明

| SQL | 锁类型 | 说明 |
|---|---|---|
| `lock tables xxx read / write` | `SHARED_READ_ONLY / SHARED_NO_READ_WRITE` | 无 |
| `select`、`select ... lock in share mode` | `SHARED_READ` | 与 `SHARED_WRITE` 兼容，与 `EXCLUSIVE` 互斥 |
| `insert`、`update`、`delete`、`select ... for update` | `SHARED_WRITE` | 与 `SHARED_READ` 兼容，与 `EXCLUSIVE` 互斥 |
| `alter table ...` | `EXCLUSIVE` | 与其他的 MDL 都互斥 |

### 3. 意向锁

- 意向共享锁（IS）
```text
由语句 SELECT ... LOCK IN SHARE MODE 添加
```

```text
与表锁共享锁（read）兼容，与表锁排他锁（write）互斥
```

- 意向排他锁（IX）
```text
由 INSERT、UPDATE、DELETE、SELECT ... FOR UPDATE 添加
```

```text
与表锁共享锁（read）及排他锁（write）都互斥。意向锁之间不会互斥
```

- 查看意向锁及行锁的加锁情况
```sql
SELECT object_schema, object_name, index_name, lock_type, lock_mode, lock_data
FROM performance_schema.data_locks;
```

## 三、行级锁

### 1. 行锁类型

- 共享锁（S）
```text
允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁
```

- 排他锁（X）
```text
允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁
```

### 2. SQL－行锁类型－说明（原笔记表格重排）

| SQL | 行锁类型 | 说明 |
|---|---|---|
| `INSERT ...` | 排他锁 | 自动加锁 |
| `UPDATE ...` | 排他锁 | 自动加锁 |
| `DELETE ...` | 排他锁 | 自动加锁 |
| `SELECT`（正常） | 不加任何锁 | 无 |
| `SELECT ... LOCK IN SHARE MODE` | 共享锁 | 需手动追加 `LOCK IN SHARE MODE` |
| `SELECT ... FOR UPDATE` | 排他锁 | 需手动追加 `FOR UPDATE` |

### 3. next-key / 间隙锁 / 临键锁

**直觉**：在 `REPEATABLE READ` 下，InnoDB 使用 next-key 锁配合索引扫描，阻止范围内插入，从而防止幻读。

- next-key 相关要点
```text
默认情况下，InnoDB在 REPEATABLE READ 事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读
```

```text
针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁
```

```text
InnoDB 的行锁是针对索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁
```

- 间隙锁 / 退化规则
```text
索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁
```

```text
索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁
```

```text
索引上的范围查询（唯一索引）会访问到不满足条件的第一个值为止
```

- 注意
```text
间隙锁唯一目的是防止其他事务插入间隙，间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁
```
