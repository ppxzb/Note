## 一、结构

### 1. B+Tree索引

#### 支持的存储引擎

```text
InnoDB、MyISAM、Memory
```

#### 特点

```text
相对于二叉树，层级更少，搜索效率高
```

```text
对于B-tree，无论是叶子点还是非叶子点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加数的高度，导致性能降低
```

```text
相对Hash索引，B+tree支持范围匹配及排序操作
```

### 2. Hash索引

#### 支持的存储引擎

```text
Memory
```

#### 特点

```text
Hash索引只能用于对等比较（=，in），不支持范围查询（between）
```

```text
无法利用索引完成排序操作
```

```text
查询效率高
```

### 3. R-tree(空间索引)

#### 支持的存储引擎

```text
MyISAM
```

### 4. Full-text(全文索引)

#### 支持的存储引擎

```text
InnoDB、MyISAM
```

## 二、分类

### 1. 索引类型（原笔记列举）

- 主键索引(PRIMARY)  
- 唯一索引(UNIQUE)  
- 常规索引  
- 全文索引(FULLTEXT)  

### 2. InnoDB存储引擎

#### 聚集索引(Clustered Index) 选取规则（原笔记要点）

```text
如果存在主键，主键索引就是聚集索引
```

```text
如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引
```

```text
如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引
```

#### 二级索引(Secondary Index)

## 三、语法

### 1. 创建索引

```sql
CREATE [UNIQUE] [FULLTEXT] INDEX index_name ON table_name(column_name);
```

### 2. 查看索引

```sql
SHOW INDEX FROM table_name;
```

### 3. 删除索引

```sql
DROP INDEX index_name ON table_name;
```

## 四、SQL性能分析

### 1. 查看执行频次

```sql
SHOW [GLOBAL | SESSION] STATUS LIKE 'Com_______';
```

### 2. 慢查询日志

- 查询功能开关
```sql
SHOW VARIABLES LIKE 'Slow_query_log';
```

- 配置（在 MySQL 配置文件 `/etc/my.cnf` 中配置）
```text
slow_query_log=1
```

```text
long_query_time=2
```

- 日志文件存放位置
```text
/var/lib/mysql/localhost-slow.log
```

### 3. show profile（执行耗时）

- 查询数据库是否支持
```sql
SELECT @@HAVA_PROFILING;
```

- 查询功能开关
```sql
SELECT @@PROFILING;
```

- 打开功能开关
```sql
SET PROFILING = 1;
```

- 查看执行耗时
```sql
SHOW PROFILES;
SHOW PROFILE FOR QUERY query_id;
SHOW PROFILE CPU FOR QUERY query_id;
```

### 4. explain（执行计划）

- 语法
```sql
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
```

- 执行计划各字段含义（原笔记要点）
  - `id`：select 查询的序列号（id 相同从上到下；id 不同值越大越先执行）  
  - `select_type`：表示 SELECT 的类型  
  - `type`：连接类型；原笔记性能从好到差：`NULL、system、const、eq_ref、range、index、all`  
  - `possible_key`：可能应用在该表上的索引（一个或多个）  
  - `key`：实际使用的索引  
  - `key_len`：索引中使用的字节数（越短越好）  
  - `rows`：MySQL 认为必须读取的行数（InnoDB 中为估计值）  
  - `filtered`：返回结果的行数占需读取行数的百分比（越大越好）  

## 五、使用原则

### 1. 最左前缀法则

```text
如果索引了多列（联合索引），要遵守最左前缀法则
```

```text
查询从索引的最左列开始，并且不跳过索引中的列
```

```text
如果跳过某一列，索引将部分失效
```

### 2. 范围查询

```text
联合索引中，出现范围查询（>，<)，范围查询右侧的列表失效
```

### 3. 索引列运算

```text
不要在索引列上进行运算操作，索引将失效
```

### 4. 字符串不加引号

```text
字符串类型字段使用时，不加引号，索引将失效
```

### 5. 模糊查询

```text
如果仅仅是尾部模糊匹配，索引不会失效
```

```text
如果是头部模糊匹配，索引失效
```

### 6. or 连接的条件

```text
用or分割开的条件，如果or前的条件中的列有索引，那么涉及的索引都不会被用到
```

### 7. 数据分布影响

```text
如果MySQL评估使用索引比全表更慢，则不使用索引
```

### 8. SQL提示

```text
use index
ignore index
force index
```

### 9. 覆盖索引

```text
尽量使用覆盖索引，减少 select *
```

### 10. 前缀索引

- 创建语法
```sql
CREATE INDEX idx_column_n ON table_name(column(n));
```

- 确定前缀长度
```sql
SELECT COUNT(DISTINCT column) / COUNT(*) FROM table_nameA;
SELECT COUNT(DISTINCT substring(column, 1, n)) / COUNT(*) FROM table_name;
```

### 11. 单列索引和联合索引

## 六、设计原则

```text
针对于数据量较大，且查询比较频繁的表建立索引
```

```text
针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引
```

```text
尽量选择区分度高的列作为索引，尽量建立唯一索引
```

```text
字符串字段长度较长，可建立前缀索引
```

```text
尽量使用联合索引，减少单列索引，避免回表，提高查询效率
```

```text
要控制索引的数量，索引越多，维护代价越大，会影响增删改效率
```

```text
如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它
```
